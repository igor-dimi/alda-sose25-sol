[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms and Data Structures SoSe 25 Solutions",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "sh01/sh01.html",
    "href": "sh01/sh01.html",
    "title": "1  Sheet 1",
    "section": "",
    "text": "Friday the 13th\nEvery now and then friday coincides with the 13th day of a month. How often does this happen?\nFirst we define a function to determine whether a year is a leap year:\ndef is_leap(year) -&gt; bool :\n    \"\"\"output true iff year is a leap year\n    precondition: year &gt;= 0\n    \n    &gt;&gt;&gt; is_leap(1999)\n    False\n    &gt;&gt;&gt; is_leap(2000)\n    True\n    &gt;&gt;&gt; is_leap(1900)\n    False\n    \"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\nprint(\n    is_leap(2000),\n    is_leap(1999),\n    is_leap(1900))\n\nTrue False False\nNext we write a function that converts the day of a year to the day of the month that this day would fall on. This function takes leap years into account:\ndef convert_day(year_day, isLeap = False) : \n    \"\"\"convert a year day to a month day\n    \n    precondition: year_day in [1...365] for default call  \n    precondition: year_day in [1...366] for leap year call, with isLeap = True  \n    for a given year day year_day returns the day of the month the day falls on  \n    taking into account if a year is a leap year with the isLeap parameter  \n\n    &gt;&gt;&gt; convert_day(1)\n    1 # 1st day of a year is the 1st day of January\n    &gt;&gt;&gt; convert_day(255)\n    12 # 255th day of a year is the 12th day of August\n    &gt;&gt;&gt; convert_day(60, True)\n    29 # 60th day of a leap year is the 29th day of February\n    &gt;&gt;&gt; convert_day(366, True)\n    31 # the last of a leap year is the 31th December\n    \"\"\"    \n\n    # Days in each month (non-leap year)\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if isLeap : months[1] = 29\n    \n    i = 0 # month number starting with 0\n    s = 0 # accumulates the sum of the days in months\n    # invariant: s == sum(months[0..i-1]) and day &gt; s\n    while year_day &gt; s + months[i] :\n        s += months[i]\n        i += 1\n    # sum(months[0..i-1]) == s &lt; day &lt;= s + months[i] == sum(months[0..i])\n    return year_day - s\nWe test the function for a few days, including\nprint(\n    convert_day(1), \n    convert_day(255), \n    convert_day(366, True),\n    convert_day(60, True), sep = '\\n'\n)\n\n1\n12\n31\n29\nNext we compute the days of the year that fall on the 13th day of a month, both for a leap and a non-leap year.\nWe will use this information in the next function.\nthirteenth_days = []\nfor i in range(1, 366) : \n    if convert_day(i) == 13 : thirteenth_days.append(i)\n\nthirteenth_days\n\nthirteenth_days_leap = []\nfor i in range(1, 367) : \n    if convert_day(i, True) == 13 : thirteenth_days_leap.append(i)\n\nprint(thirteenth_days, \n    thirteenth_days_leap, sep = '\\n')\n\n[13, 44, 72, 103, 133, 164, 194, 225, 256, 286, 317, 347]\n[13, 44, 73, 104, 134, 165, 195, 226, 257, 287, 318, 348]\nNow we define a function that accepts a parameter that stands for the day of the week, ranging from 0 to 6, representing the days Mo, …, Sun.\nThis input parameter is the day of the week that the first 13th day of the month (i.e. January 13th) fell on.\nE.g. if January 13th was Wednesday that year, then the input parameter is 2. If the year is a leap year a second default boolean parameter is provided as True.\ndef days_of_the_week_that_are_thirteenth(i, isLeap = False) :\n    \"\"\"return an array that contains the days of the week  \n    that are the thirteenth day of the month\n\n    days are numbered from 0 to 6 corresponding to days Mon .. Sun  \n    input parameter i is the number of the first 13th day. It can  \n    be any day of the week. E.g. if in a given year Januaray 13th was Monday  \n    then i is 0. \n    \n    \"\"\"\n\n    thirteenth_days = [13, 44, 72, 103, 133, 164, 194, 225, 256, 286, 317, 347]\n    if isLeap : \n        thirteenth_days = [13, 44, 73, 104, 134, 165, 195, 226, 257, 287, 318, 348]\n\n\n    \n    b = [None] * len(thirteenth_days)\n    b[0] = i\n    for j in range(1, len(thirteenth_days)) :\n        b[j] = (b[j - 1] + (thirteenth_days[j] - thirteenth_days[j - 1])) % 7\n    return b\n\n\nprint(days_of_the_week_that_are_thirteenth(1), \n    days_of_the_week_that_are_thirteenth(3, True), sep = '\\n')\n\n[1, 4, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6]\n[3, 6, 0, 3, 5, 1, 3, 6, 2, 4, 0, 2]\nNote that January 13th can be any day of the week from Monday to Sunday for a given year. This function computes the days of the week all the 13th days of a month fall on given the day of the week 13th January falls on that year. E.g. for the year 1993, January 13th was a Wednesday. So the input parameter is simply the number 2.\nAll the other 13th days of other months are computed that as follows with this function:\nprint(days_of_the_week_that_are_thirteenth(2, is_leap(1993)))\n\n[2, 5, 5, 1, 3, 6, 1, 4, 0, 2, 5, 0]\nFrom this result we see that the year 1993 had only one Friday the 13th - on August.\nNext we define another function that computes the first day of any year after (and including) 1 A.D.\nIt is assumed that the first day of the first year was a Monday. The first years of all other years are computed accordingly and taking leap years into account:\ndef first_day_of_year(year) :\n    \"\"\"return the first day of a year given as input parameter  \n    where days are numbered 0..6 starting from monday\n    precondition: year &gt;= 1\n\n\n    &gt;&gt;&gt; first_day_of_year(1999)\n\n    \"\"\"\n    days_past = 0\n    for i in range(1, year) : \n        if is_leap(i) : days_past += 366\n        else : days_past += 365\n    return days_past % 7\nLet’s test this function to find out the what day of the week the first days of the first 5 years fell on:\nfor i in range(1, 6) : print(first_day_of_year(i))\n\n0\n1\n2\n3\n5\nFirst day of year 1993:\nfirst_day_of_year(1993)\n\n4\nNow we are ready to generate all the 13th days of all months of years ranging from 1993 to 2025.\nthirteenth_days = []\nfor y in range(1993, 2026) :\n    first_day = first_day_of_year(y)\n    first_thirteenth_day = (first_day + 12) % 7\n    thirteenth_days.append(days_of_the_week_that_are_thirteenth(first_thirteenth_day, is_leap(y)))\nthirteenth_days holds 33 arrays, each holding 12 values, that contains the days of the week that the 13th of the corresponding month fell on:\nprint(thirteenth_days)\n\n[[2, 5, 5, 1, 3, 6, 1, 4, 0, 2, 5, 0], [3, 6, 6, 2, 4, 0, 2, 5, 1, 3, 6, 1], [4, 0, 0, 3, 5, 1, 3, 6, 2, 4, 0, 2], [5, 1, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4], [0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5], [1, 4, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6], [2, 5, 5, 1, 3, 6, 1, 4, 0, 2, 5, 0], [3, 6, 0, 3, 5, 1, 3, 6, 2, 4, 0, 2], [5, 1, 1, 4, 6, 2, 4, 0, 3, 5, 1, 3], [6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4], [0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5], [1, 4, 5, 1, 3, 6, 1, 4, 0, 2, 5, 0], [3, 6, 6, 2, 4, 0, 2, 5, 1, 3, 6, 1], [4, 0, 0, 3, 5, 1, 3, 6, 2, 4, 0, 2], [5, 1, 1, 4, 6, 2, 4, 0, 3, 5, 1, 3], [6, 2, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5], [1, 4, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6], [2, 5, 5, 1, 3, 6, 1, 4, 0, 2, 5, 0], [3, 6, 6, 2, 4, 0, 2, 5, 1, 3, 6, 1], [4, 0, 1, 4, 6, 2, 4, 0, 3, 5, 1, 3], [6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4], [0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5], [1, 4, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6], [2, 5, 6, 2, 4, 0, 2, 5, 1, 3, 6, 1], [4, 0, 0, 3, 5, 1, 3, 6, 2, 4, 0, 2], [5, 1, 1, 4, 6, 2, 4, 0, 3, 5, 1, 3], [6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4], [0, 3, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6], [2, 5, 5, 1, 3, 6, 1, 4, 0, 2, 5, 0], [3, 6, 6, 2, 4, 0, 2, 5, 1, 3, 6, 1], [4, 0, 0, 3, 5, 1, 3, 6, 2, 4, 0, 2], [5, 1, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4], [0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5]]\nTo find out how many times ‘Friday the 13th’ was experienced since 1993, we simply have to count and add iup each occurrence of ‘4’ (Friday) in each array:\ncount = 0\nfor days in thirteenth_days :\n    for day in days :\n        if day == 4 : count += 1\n\nprint(count)\n\n55\nSo Friday the 13th was experienced 55 times in total since year 1993. Finally, we can encapsulate all of this computation in a single function:\ndef count_friday_13th_since(year) :\n    thirteenth_days = []\n    for y in range(year, 2026) :\n        first_day = first_day_of_year(y)\n        first_thirteenth_day = (first_day + 12) % 7\n        thirteenth_days.append(\n            days_of_the_week_that_are_thirteenth(first_thirteenth_day, is_leap(y)))\n    count = 0\n    for days in thirteenth_days :\n        for day in days :\n            if day == 4 : count += 1\n    return count\n\n\ncount_friday_13th_since(2000)  \n\n44",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh01/sh01.html#friday-the-13th",
    "href": "sh01/sh01.html#friday-the-13th",
    "title": "1  Sheet 1",
    "section": "",
    "text": "1st day of a non-leap year: January 1st\n255th day of a non-leap year: September 12th\n366th day of a leap year: December 31st\n60th day of a leap year: February 29th",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh01/sh01.html#stable-glasses",
    "href": "sh01/sh01.html#stable-glasses",
    "title": "1  Sheet 1",
    "section": "Stable Glasses",
    "text": "Stable Glasses\n\nLinear search: 30 tries in worst case, corresponding to the situation when the glass breaks at the highest platform. We start at the bottom platfrom and move to the next higher one if the glass doesn’t break. As soon as the glass breaks we know that the platform just below is the maximum height the glass can withstand..\nBinary search: 5 tries always. In worst case each time we try the glass breaks. Therefore, maximum amount of broken glasses is 5. This corresponds to the situation where no height is safe for the glass.\nJustification: The general strategy is the same as with binary search - we first try the middle platform, i.e. 15th platform. In case the glass doesn’t break we know that we must search only in the upper half. Otherwise, we must search only in the lower half. Since in each step we half the amount of platforms the procedure is guaranteed to terminate in approximately \\(\\log_2{30}\\) steps. How many exactly can be seen with the following sequence: 15, 8, 4, 2, 1. Explanation of this sequence is that the middle platform where we have to perform the experiment is determined by the formula: (total platforms left + 1) // 2. And the total platforms left in the next step is always the number of the middle platform from the previous step. So in total there will be 5 steps and each time a glass will break.\nIn this case we can determine the highest platform in 11 steps at worst case with the following procedure (by dividing the stand in 3 equal parts)\n\nTest first glass in the highest platform in the lower third, i.e. the 11th platform. If it breaks then we must test the other glass in the remaining 10 platforms in the lower third linearly until it breaks the first time: 10 + 1 = 11 tries at worst.\nif the first glass doesn’t break, then we try the lowest platform in the upper third, i.e. the 21st platform with this glass. If the glass breaks here, then we search the middle third, i.e. we test the platforms 12..20 with the other glass linearly, until it breaks. This totals to 1 + 1 + 9 = 11 tries in worst case.\nIf first glass doesn’t break in the 21st platform, then we continue to search the upper third platform with it, namely the platforms 22…30, linearly until the glass breaks or we reach the end. This totals to 1 + 1 + 9 = 11 tries in worst case.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh01/sh01.html#python-documentation",
    "href": "sh01/sh01.html#python-documentation",
    "title": "1  Sheet 1",
    "section": "Python Documentation",
    "text": "Python Documentation\nChapters 3, 4.1 - 4.9.2, 8.1 - 8.4, 9.3, and 10.6\n\ndef reverse(s) :\n    if len(s) == 0 : return s\n    return s[-1] + reverse(s[: len(s) - 1])\n\n\nreverse('he')\n\n'eh'\n\n\n\ndef palindrom(s) -&gt; bool :\n    return s == reverse(s)\n\n\npalindrom('ccababaccd')\n\nFalse\n\n\n\ndef fib(limit):\n    a, b = 0, 1\n    # \n    # there exist i: a == fib(i), b == fib(i + 1)\n    while (a &lt; limit) :\n        a, b = b, a + b\n    # a &gt;= limit\n    return(a)\n    \n\n\nfib(144)\n\n144\n\n\n\nd = {\"a\" : \"active\", \"b\" : \"inactive\", \"c\" : \"active\"}\n\nfor i, j in d.items() : \n    print(i, j)\n\nfor i, j in d.copy().items() :\n    if j == 'inactive' : del d[i]\n\nd2 = {}\nd2[\"igor\"] = 31\nd2[\"igor\"] += 1\nd2\n\na active\nb inactive\nc active\n\n\n{'igor': 32}\n\n\n\nlist(range(5, 10))\nlist(range(0, 10, 3))\nlist(range(-10, -100, -30))\n\na = ['mary', 'had', 'a', 'little', 'lamb']\nb = []\nfor i in range(len(a)):\n    b.append((i, a[i]))\n\nb\nd = dict(b)\nd\n\nfor i, word in enumerate(a) :\n    print(f\"{i}: {a[i]}\" + i**2*\"!\")\n\n0: mary\n1: had!\n2: a!!!!\n3: little!!!!!!!!!\n4: lamb!!!!!!!!!!!!!!!!\n\n\n\ndict(enumerate(list(range(5))))\n\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n\n\n\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0: \n            print(f\"{n} equals {x} * {n // x}\")\n            break \n    else: # loop fell through withouit finding a factor\n        print(n, 'is a prime number')\n        \n\n\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n\n\n\nfor num in range(2, 10):\n    if num % 2 == 0:\n        print(f\"Found an even number {num}\")\n        continue\n    print(f\"Found an odd number {num}\")\n\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n\n\n\ndef http_error(status):\n    match status:\n        case 400: return \"Bad Request\"\n        case 404: return \"Not found\"\n        case 418: return \"I'm a teapot\"\n        case 401 | 403 | 402: return \"Not allowed\"\n        case _: return \"Something's wrong\"\n\nfor i in [400, 404, 418, 134] : print(http_error(i))\n\nfor i in ['a', 'b']: print(i)\n\nprint(http_error(401))\n\nBad Request\nNot found\nI'm a teapot\nSomething's wrong\na\nb\nNot allowed\n\n\n\nnums = [1, 2, 3]\na, b, c = nums\nprint(a, b, c)\n\ndef add(a, b, c) :\n    return a + b + c\n\nadd(1, 2, 3)\nadd(*nums)\n\na, *b, c = [1, 2, 3, 4]\nprint(a, b, c)\na, *b, c = 1, 2, 3, 4\nprint(a, b, c)\n\n1 2 3\n1 [2, 3] 4\n1 [2, 3] 4\n\n\n\nx, y = 1, 2\nprint(x, y)\nx, y = [1, 2]\nprint(x, y)\nx, y = (1, 2)\nprint(x, y)\n\n*head, last = 1, 2, 3, 4\nprint(head, last)\n*head, last = [1, 2, 3, 4]\nprint(head, last)\nfirst, *middle, last = (1, 2, 3, 4, 5)\nprint(first, middle, last)\nx,*_, z = 1, 2, 3, 4\nprint(x, z)\na, *b, c, d = range(10)\nprint(a, b, c, d)\n\n1 2\n1 2\n1 2\n[1, 2, 3] 4\n[1, 2, 3] 4\n1 [2, 3, 4] 5\n1 4\n0 [1, 2, 3, 4, 5, 6, 7] 8 9\n\n\n** operator works with dictionaries to unpack keyword arguments\n\ndef greet(name, greeting):\n    print(f\"{greeting}, {name}!\")\n\nparams = {\"name\": \"Alice\", \"greeting\": \"Hello\"}\n\ngreet(**params)\n\nHello, Alice!\n\n\n\na, *b, c = 1,2\n# print(a, b, c)\n\ndef foo(a, *args, **kwargs):\n    print(a)\n    print(args)\n    print(kwargs)\n\nfoo(1, 2, 3, 4, x = 10, y = 20, z = 30)\n\n1\n(2, 3, 4)\n{'x': 10, 'y': 20, 'z': 30}\n\n\n\ndef bar(*args):\n    print(args)\n\n\nl = [1, 2, 3]\n\nbar(l, *l)\n\n([1, 2, 3], 1, 2, 3)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh02/sh02.html",
    "href": "sh02/sh02.html",
    "title": "2  Sheet 2",
    "section": "",
    "text": "Properties of Sorting Algorithms\nWe modify them slightly to return the number of comparisons:\ndef insertion_sort(a) :\n    N = len(a)\n    count = 0\n    # i = 1\n    # sorted(a[0..i-1])\n    for i in range(1, N):\n        k = i\n        while k &gt; 0 :\n            if a[k] &lt; a[k-1]: \n                a[k], a[k-1] = a[k-1], a[k]\n                count += 1\n            else: \n                count += 1\n                break\n            k -= 1\n    return count\ndef partition(a, l, r):  # l, r are left and right boundaries (inclusive) of a\n    count = 0\n    p = random.randint(l, r)\n    a[p], a[r] = a[r], a[p]\n    pivot = a[r]\n    i = l\n    k = r - 1\n    while True:\n        while i &lt; r and a[i] &lt;= pivot: \n            i += 1 # increment until found a misplaced element\n            count += 1\n        while k &gt; l and a[k] &gt;= pivot: \n            k -= 1 # decrement until found a misplaced element\n            count += 1\n        if i &lt; k : a[i], a[k] = a[k], a[i]\n        else : break\n    a[i], a[r] = a[r], a[i] # bring pivot to the correct position\n    return i, count # so that recursive calls now where the partitions are \n\n# implementation of quicksort with arbitrary array boundaries\ndef quick_sort_impl(a, l, r):\n    if r &lt;= l: return 0# no return argument since in-place\n    i, count = partition(a, l, r)\n    count += quick_sort_impl(a, l, i-1)\n    count += quick_sort_impl(a, i+1, r)\n    return count\n\n# the clean user interface\ndef quick_sort(a) :\n    return quick_sort_impl(a, 0, len(a) - 1)\nNow we write a simple script that aggregates the counts of sorts in lists, and subsequently plot the lists:\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef create_counts(sorting_function, shuffle = True, MAX = 100):\n    counts_array = []\n    for N in range(MAX):\n        count = 0 \n        for i in range(5):\n            a = list(range(N))\n            if shuffle :\n                random.shuffle(a)\n            count += sorting_function(a)\n        count /= 5\n        counts_array.append(count)\n    return counts_array\n\ninsertion_counts = create_counts(insertion_sort)\n\nquick_counts = create_counts(quick_sort)\n\n# insertion_sorted_counts = create_counts(insertion_sort, False)\n\n# --- Prepare input sizes ---\nN_values = np.arange(100)\n\n# --- Theoretical curves with estimated constants ---\nd1, e1, f1 = 0.25, 0, 0  # Insertion Sort: Quadratic\nd2, e2, f2 = 0.9, 0, 0   # Quick Sort: N log N\n\ninsertion_theoretical = d1 * N_values**2 + e1 * N_values + f1\nquick_theoretical = d2 * N_values * np.log2(N_values + 1) + e2 * N_values + f2\n\n# --- Plot everything ---\nplt.plot(insertion_counts, label=\"Insertion Sort (Empirical)\")\nplt.plot(quick_counts, label=\"Quick Sort (Empirical)\")\n# plt.plot(insertion_sorted_counts, label=\"Insertion Sort (Sorted Input)\")\n\nplt.plot(N_values, insertion_theoretical, 'k--', label=\"~ 0.25·N²\")  # Dashed black\nplt.plot(N_values, quick_theoretical, 'r--', label=\"~ 0.9·N·log₂(N)\")  # Dashed red\n\nplt.xlabel(\"Input Size N\")\nplt.ylabel(\"Operation Count\")\nplt.title(\"Empirical vs Theoretical Sorting Performance\")\nplt.legend()\nplt.grid(True)\nplt.show()\nWe see that insertion sort is well approximated by the function \\(0.25\\cdot N^2\\) and quick sort by \\(0.9\\cdot N\\cdot\\log_2{N}\\), confirming our theoretical expectations.\nNext we do the same for already sorted arrays:\ninsertion_counts = create_counts(insertion_sort, False)\nquick_counts = create_counts(quick_sort, False)\n\n# --- Prepare input sizes ---\nN_values = np.arange(100)\n\n# --- Theoretical curves with estimated constants ---\nd1, e1 = 1, 0  # Insertion Sort: Quadratic\nd2, e2, f2 = 0.9, 0, 0   # Quick Sort: N log N\n\n# insertion_theoretical = d1 * N_values**2 + e1 * N_values + f1\ninsertion_theoretical = d1 * N_values + e1\nquick_theoretical = d2 * N_values * np.log2(N_values + 1) + e2 * N_values + f2\n\n# --- Plot everything ---\nplt.plot(insertion_counts, label=\"Insertion Sort (Empirical)\")\nplt.plot(quick_counts, label=\"Quick Sort (Empirical)\")\n# plt.plot(insertion_sorted_counts, label=\"Insertion Sort (Sorted Input)\")\n\nplt.plot(N_values, insertion_theoretical, 'k--', label=\"~ N\")  # Dashed black\nplt.plot(N_values, quick_theoretical, 'r--', label=\"~ 0.9·N·log₂(N)\")  # Dashed red\n\nplt.xlabel(\"Input Size N\")\nplt.ylabel(\"Operation Count\")\nplt.title(\"Empirical vs Theoretical Sorting Performance - Sorted Arrays\")\nplt.legend()\nplt.grid(True)\nplt.show()\nHere we see that insertion sort is linear while quicksort is still \\(\\mathcal{O}N\\log(N)\\), approximated by the same function from previous output. Thus insertion sort outperforms quicksort for already sorted arrays.\nNext we compare how quicksort works on already sorted arrays, if the pivot is not randomly chosen, but always chosen as the right-most element - the naive version.\nWe first define this naive quick sort version:\ndef partition2(a, l, r):  # l, r are left and right boundaries (inclusive) of a\n    count = 0\n    pivot = a[r]\n    i = l\n    k = r - 1\n    while True:\n        while i &lt; r and a[i] &lt;= pivot: \n            i += 1 # increment until found a misplaced element\n            count += 1\n        while k &gt; l and a[k] &gt;= pivot: \n            k -= 1 # decrement until found a misplaced element\n            count += 1\n        if i &lt; k : a[i], a[k] = a[k], a[i]\n        else : break\n    a[i], a[r] = a[r], a[i] # bring pivot to the correct position\n    return i, count # so that recursive calls now where the partitions are \n\n# implementation of quicksort with arbitrary array boundaries\ndef quick_sort_impl2(a, l, r):\n    if r &lt;= l: return 0# no return argument since in-place\n    i, count = partition2(a, l, r)\n    count += quick_sort_impl2(a, l, i-1)\n    count += quick_sort_impl2(a, i+1, r)\n    return count\n\n# the clean user interface\ndef quick_sort2(a) :\n    return quick_sort_impl2(a, 0, len(a) - 1)\nNext we perform the same experiments from before and plot the results:\ninsertion_counts = create_counts(insertion_sort, False)\n\nquick2_counts = create_counts(quick_sort2, False)\n\nquick_counts = create_counts(quick_sort, False)\n\n# --- Prepare input sizes ---\nN_values = np.arange(100)\n\n# --- Theoretical curves with estimated constants ---\nd1, e1, f1 = 0.5, 0, 0  # Quick Sort Naive Pivot: Quadratic\nd2, e2, f2 = 0.9, 0, 0   # Quick Sort: N log N\nd3, e3 = 1, 0 # Insetion sort: linear\n\nquick2_theoretical = d1 * N_values**2 + e1 * N_values + f1\nquick_theoretical = d2 * N_values * np.log2(N_values + 1) + e2 * N_values + f2\ninsertion_theoretical = d3 * N_values + e3\n\n# --- Plot everything ---\nplt.plot(quick2_counts, label=\"Quick Sort Naive Pivot (Empirical)\")\nplt.plot(N_values, quick2_theoretical, 'r--', label=\"~ 0.5*N**2\")  # Dashed red\n\nplt.plot(quick_counts, label=\"Quick Sort Random Pivot (Empirical)\")\nplt.plot(N_values, quick_theoretical, 'c--', label=\"~ 0.9*N*log(N)\")  # Dashed red\n\nplt.plot(insertion_counts, label=\"Insertion Sort (Empirical)\")\nplt.plot(N_values, insertion_theoretical, 'k--', label=\"~ N\")  # Dashed black\n\nplt.xlabel(\"Input Size N\")\nplt.ylabel(\"Operation Count\")\nplt.title(\"Empirical vs Theoretical Sorting Performance - Sorted Array\")\nplt.legend()\nplt.grid(True)\nplt.show()\nHere we see that quicksort with naive pivot choice runs quadratically for already sorted arrays, while insetion sort is linear. Thus insertion sort outperforms naive quicksort in this case. (random pivot quicksort is still \\(\\mathcal{O}(N\\log{N})\\))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sheet 2</span>"
    ]
  },
  {
    "objectID": "sh02/sh02.html#properties-of-sorting-algorithms",
    "href": "sh02/sh02.html#properties-of-sorting-algorithms",
    "title": "2  Sheet 2",
    "section": "",
    "text": ":= means ‘defined as’:\n\na &lt; b := not ( b &lt;= a)\na &gt; b := b &lt; a (utilize the definition above)\na &gt;= b := b &lt;= a\na == b := (a &lt;= b) and (b &lt;= a)\na != b := not (a == b) (again utlizing the previous definiton)\n\nThe following \\(N - 1\\) tests are sufficient:\n1) a[0] &lt;= a[1], \n2) a[1] &lt;= a[2], \n...\nN-1) a[N-2] &lt;= a[N-1]\nProof: assume the previous \\(N - 1\\) have passed. Let \\(i\\in [0..N-2]\\) and \\(j \\in [i+1..N-1]\\) be arbitrary indices.\nSince the ordering is total, transitivity holds. Specifically having a[i] &lt;= a[i + 1] and a[i + 1] &lt;= a[i + 2] we can deduce by transitivity that a[i] &lt;= a[i + 2]. Now having this result and the condition that a[i+2] &lt;= a[i+3] we can again deduce by transitivity that a[i] &lt;= a[i + 3]\nApplying such a transitivity chain \\(j - i\\) times we will obtain a[i] &lt;= a[j]. Since \\(i\\) and \\(j\\) were arbitrary, s.t. \\(i &lt; j\\), this concludes our proof.\nThe usual versions of insertion_sort() and quick_sort(), without counting are given as:\n\ndef insertion_sort(a) :\n   N = len(a)\n   # i = 0\n   # sorted(a[0..i])\n   for i in range(N):\n      k = i + 1\n      while k &gt; 0 :\n         if a[k] &lt; a[k-1]: a[k], a[k-1] = a[k-1], a[k]\n         else: break\n         k -= 1\n\n# partition function for quicksort  \ndef partition(a, l, r):  # l, r are left and right boundaries (inclusive) of a\n   p = random.randint(l, r) # choose a random index\n   a[p], a[r] = a[r], a[p] # exchange the right-most element with the one at random index\n   pivot = a[r] \n   i = l\n   k = r - 1\n   while True:\n      while i &lt; r and a[i] &lt;= pivot: i += 1 # increment until found a misplaced element\n      while k &gt; l and a[k] &gt;= pivot: k -= 1 # decrement until found a misplaced element\n      if i &lt; k : a[i], a[k] = a[k], a[i]\n      else : break\n   a[i], a[r] = a[r], a[i] # bring pivot to the correct position\n   return i # so that recursive calls now where the partitions are \n\n# implementation of quicksort with arbitrary array boundaries\ndef quick_sort_impl(a, l, r):\n   if r &lt;= l: return # no return argument since in-place\n   i = partition(a, l, r)\n   quick_sort_impl(a, l, i-1)\n   quick_sort_impl(a, i+1, r)\n\n# the clean user interface\ndef quick_sort(a) :\n   quick_sort_impl(a, 0, len(a) - 1)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sheet 2</span>"
    ]
  },
  {
    "objectID": "sh03/03.html",
    "href": "sh03/03.html",
    "title": "3  Blatt 03",
    "section": "",
    "text": "Problem 1\nWe use a slightly different, more convenient method based on Hoare calculus and the program derivation methodoloy of Dijkstra. In this methodology pre- and postconditions, as well as loop invariants are provided directly within the program text as comments.\nA commment before a command is a logical statement about the state-space of the program before the execution of the command, i.e. the precondition, and the comment after is the postcondition.\nThe comment before a while or a for loop is specifically labeled as ‘invariant’ and is the invariant statement that stays true after the execution of the loop. The general form of such specification is:\nThis expression means: if P holds before the execution of C then Q will hold after the execution of C. For example:\nor\nor\nor more compactly\nIn the above program we exchnaged the values of variables x, and y without using a temporary varible t. But as a furhter example of pre- and postcondition specification let’s do that:\nThe semantics of while loops is given as follows:\nif\nWhere C is an arbitrary command, or a sequence of commands.\nThen:\nSo what we have to show is that:\nHaving shown 1) and 2) we can conclude:\nA simple example: incrementing a variable i up to a value N, where it is assumed that N &gt;= 0\nSo, after exiting the loop the following holds:\nLet’s apply this scheme to the division example:\ndef div(x, y):\n    # precondition: x &gt;= 0, y &gt; 0\n    q = 0 \n    r = x\n    # invariant: x == r + q * y and r &gt;= 0\n    while r &gt;= y:\n        r -= y\n        q += 1\n    # r &lt; y \n    return (q, r)\n\nprint(f\"31/9 == {div(31, 9)[1]} + 9 * {div(31,9)[0]}\")\n\n31/9 == 4 + 9 * 3\nProof:\nNow after exiting the loop in addition to the invariant the negation of the loop condition holds. Thus we have:\nWhich is exactly satisfies the condition of whole number division.\nBelow we give the trace of the execution of the algorith for x == 31 and y == 9 with a short explanation of Hoare-style secification:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Blatt 03</span>"
    ]
  },
  {
    "objectID": "sh03/03.html#problem-1",
    "href": "sh03/03.html#problem-1",
    "title": "3  Blatt 03",
    "section": "",
    "text": "# P\nC\n# Q\n\n# x == 0\nx += 1\n# x == 1\n\n# y &gt; 0\ny -= 1\n# y &gt;= 0\n\n# x == X and y == Y\nx += y\n# x == X + Y and y == Y\ny = x - y\n# x == X + Y and Y == X\nx -= y\n# x == X and Y == X\n\n# x == X and y == Y\nx += y\ny =  x - y\nx = x - y\n# x == Y and y == X\n\n# x == X and y == Y\nt = x\n# t == X\nx = y\n# x == Y\ny = t\n# y == X\n\n\n# P and Q\nC\n# P\n\n\n# invariant: P\nwhile Q :\n    C\n# P and !Q\n\n\nP holds before the execution of the loop, before C is executed (induction base)\nif Q holds additionally then P still holds after C is executed (inductive step)\n\n\n\nAfter exiting the loop (P and !Q) holds\n\n\ni = 0\n# invariant: i &lt;= N (since we know that 0 &lt;= N)\nwhile i &lt; N:\n    i += 1\n# i &gt;= N\n\nIB: Before the loop executes: i == 0 &lt;= N, by assumption.\nIS: if i &lt;= N and i &lt; N simply implies i &lt; N. if i &lt; N holds before incrementation, then i &lt;= N will hold after the incrementation, by simple arithmetic rules, which proves the invariant.\n\n\n\ni &lt;= N and !(i &lt; N). which is exactly equivalent to i == N, what\n\n\n\n\n\nIB: before the loop executes we have; q == 0 and 0 &lt;= x == r therefore x == r + q * y and r &gt;= 0 holds trivially.\nIS: assume the invariant holds before some arbitrary execution of the loop. Assume that r &gt;= y additionally holds, so we are in the body of the loop. Now since the invariant holds we have\nx == r + q * y and r &gt;= 0 and r &gt;= y\nwe can manipulate r + q * y as follows:\nr + q * y == (r - y) + (q + 1) * y\nSo after executing the body of the loop the r holds what previously was r - y and q holds what previously was q + 1. But as shown above this leaves the value of expression unchanged, therefore after updating the variables r and q in the body of the loop the equality x == r + q * y still holds.\nNow we turn our attention to the second conjunct of the invariant: r &gt;= 0. Since r &gt;= y holds in the body of the loop, r &gt;= 0 still holds after the update to r - r -= y.\nThese two observations conclude our proof\n\n\n\nx == r + q * r and r &gt;= 0 and !(r &gt;= y) iff x == r + q * r and 0 &lt;= r &lt; y\n\n\n\n\nHoare Logic Specification for Integer Division\nProblem: Implement integer division with remainder using repeated subtraction.\nFunction:\ndef div(x, y):\n    # Precondition: x ≥ 0 ∧ y &gt; 0\n    q = 0\n    r = x\n    # Invariant: x == r + q * y ∧ r ≥ 0\n    while r &gt;= y:\n        r = r - y\n        q = q + 1\n    # Postcondition: x == q * y + r ∧ 0 ≤ r &lt; y\n    return (q, r)\n\n\nHoare Triple:\n\\[\n\\{\\, x \\geq 0 \\wedge y &gt; 0 \\,\\} \\\\\n\\texttt{div(x, y)} \\\\\n\\{\\, x = q \\cdot y + r \\wedge 0 \\leq r &lt; y \\,\\}\n\\]\n\nInvariant: \\(x = r + q \\cdot y \\quad \\wedge \\quad r \\geq 0\\)\nTermination: Each iteration decreases r by y while keeping r ≥ 0 therefore the loop will eventually terminate.\n\n\n\nExecution Trace: div(31, 9)\nInitial values: x = 31, y = 9\n\n\n\n\n\n\n\n\n\nq\nr\nInvariant: r + y * q == x ∧ r ≥ 0\nLoop condition (r ≥ y)\n\n\n\n\n0\n31\n31 + 9 * 0 = 31 ∧ 31 ≥ 0 → true\n31 ≥ 9 → true\n\n\n1\n22\n22 + 9 * 1 = 31 ∧ 22 ≥ 0 → true\n22 ≥ 9 → true\n\n\n2\n13\n13 + 9 * 2 = 31 ∧ 13 ≥ 0 → true\n13 ≥ 9 → true\n\n\n3\n4\n4 + 9 * 3 = 31 ∧ 4 ≥ 0 → true\n4 ≥ 9 → false\n\n\n\n\nThe loop terminates when r &lt; y, here r = 4 &lt; 9.\nFinal return: (q, r) = (3, 4)\nConfirming: \\(31 = 9 \\cdot 3 + 4\\)\n\nThis demonstrates partial correctness (postcondition holds if it terminates), and the termination argument ensures total correctness.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Blatt 03</span>"
    ]
  }
]