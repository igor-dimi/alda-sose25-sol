[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms and Data Structures SoSe 25 Solutions",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "sh01/sh01.html",
    "href": "sh01/sh01.html",
    "title": "1  Sheet 1",
    "section": "",
    "text": "Friday the 13th\nEvery now and then friday coincides with the 13th day of a month. How often does this happen?\nFirst we define a function to determine whether a year is a leap year:\ndef is_leap(year) -&gt; bool :\n    \"\"\"output true iff year is a leap year\n    precondition: year &gt;= 0\n    \n    &gt;&gt;&gt; is_leap(1999)\n    False\n    &gt;&gt;&gt; is_leap(2000)\n    True\n    &gt;&gt;&gt; is_leap(1900)\n    False\n    \"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\nprint(\n    is_leap(2000),\n    is_leap(1999),\n    is_leap(1900))\n\nTrue False False\nNext we write a function that converts the day of a year to the day of the month that this day would fall on. This function takes leap years into account:\ndef convert_day(year_day, isLeap = False) : \n    \"\"\"convert a year day to a month day\n    \n    precondition: year_day in [1...365] for default call  \n    precondition: year_day in [1...366] for leap year call, with isLeap = True  \n    for a given year day year_day returns the day of the month the day falls on  \n    taking into account if a year is a leap year with the isLeap parameter  \n\n    &gt;&gt;&gt; convert_day(1)\n    1 # 1st day of a year is the 1st day of January\n    &gt;&gt;&gt; convert_day(255)\n    12 # 255th day of a year is the 12th day of August\n    &gt;&gt;&gt; convert_day(60, True)\n    29 # 60th day of a leap year is the 29th day of February\n    &gt;&gt;&gt; convert_day(366, True)\n    31 # the last of a leap year is the 31th December\n    \"\"\"    \n\n    # Days in each month (non-leap year)\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if isLeap : months[1] = 29\n    \n    i = 0 # month number starting with 0\n    s = 0 # accumulates the sum of the days in months\n    # invariant: s == sum(months[0..i-1]) and day &gt; s\n    while year_day &gt; s + months[i] :\n        s += months[i]\n        i += 1\n    # sum(months[0..i-1]) == s &lt; day &lt;= s + months[i] == sum(months[0..i])\n    return year_day - s\nWe test the function for a few days, including\nprint(\n    convert_day(1), \n    convert_day(255), \n    convert_day(366, True),\n    convert_day(60, True), sep = '\\n'\n)\n\n1\n12\n31\n29\nNext we compute the days of the year that fall on the 13th day of a month, both for a leap and a non-leap year.\nWe will use this information in the next function.\nthirteenth_days = []\nfor i in range(1, 366) : \n    if convert_day(i) == 13 : thirteenth_days.append(i)\n\nthirteenth_days\n\nthirteenth_days_leap = []\nfor i in range(1, 367) : \n    if convert_day(i, True) == 13 : thirteenth_days_leap.append(i)\n\nprint(thirteenth_days, \n    thirteenth_days_leap, sep = '\\n')\n\n[13, 44, 72, 103, 133, 164, 194, 225, 256, 286, 317, 347]\n[13, 44, 73, 104, 134, 165, 195, 226, 257, 287, 318, 348]\nNow we define a function that accepts a parameter that stands for the day of the week, ranging from 0 to 6, representing the days Mo, …, Sun.\nThis input parameter is the day of the week that the first 13th day of the month (i.e. January 13th) fell on.\nE.g. if January 13th was Wednesday that year, then the input parameter is 2. If the year is a leap year a second default boolean parameter is provided as True.\ndef days_of_the_week_that_are_thirteenth(i, isLeap = False) :\n    \"\"\"return an array that contains the days of the week  \n    that are the thirteenth day of the month\n\n    days are numbered from 0 to 6 corresponding to days Mon .. Sun  \n    input parameter i is the number of the first 13th day. It can  \n    be any day of the week. E.g. if in a given year Januaray 13th was Monday  \n    then i is 0. \n    \n    \"\"\"\n\n    thirteenth_days = [13, 44, 72, 103, 133, 164, 194, 225, 256, 286, 317, 347]\n    if isLeap : \n        thirteenth_days = [13, 44, 73, 104, 134, 165, 195, 226, 257, 287, 318, 348]\n\n\n    \n    b = [None] * len(thirteenth_days)\n    b[0] = i\n    for j in range(1, len(thirteenth_days)) :\n        b[j] = (b[j - 1] + (thirteenth_days[j] - thirteenth_days[j - 1])) % 7\n    return b\n\n\nprint(days_of_the_week_that_are_thirteenth(1), \n    days_of_the_week_that_are_thirteenth(3, True), sep = '\\n')\n\n[1, 4, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6]\n[3, 6, 0, 3, 5, 1, 3, 6, 2, 4, 0, 2]\nNote that January 13th can be any day of the week from Monday to Sunday for a given year. This function computes the days of the week all the 13th days of a month fall on given the day of the week 13th January falls on that year. E.g. for the year 1993, January 13th was a Wednesday. So the input parameter is simply the number 2.\nAll the other 13th days of other months are computed that as follows with this function:\nprint(days_of_the_week_that_are_thirteenth(2, is_leap(1993)))\n\n[2, 5, 5, 1, 3, 6, 1, 4, 0, 2, 5, 0]\nFrom this result we see that the year 1993 had only one Friday the 13th - on August.\nNext we define another function that computes the first day of any year after (and including) 1 A.D.\nIt is assumed that the first day of the first year was a Monday. The first years of all other years are computed accordingly and taking leap years into account:\ndef first_day_of_year(year) :\n    \"\"\"return the first day of a year given as input parameter  \n    where days are numbered 0..6 starting from monday\n    precondition: year &gt;= 1\n\n\n    &gt;&gt;&gt; first_day_of_year(1999)\n\n    \"\"\"\n    days_past = 0\n    for i in range(1, year) : \n        if is_leap(i) : days_past += 366\n        else : days_past += 365\n    return days_past % 7\nLet’s test this function to find out the what day of the week the first days of the first 5 years fell on:\nfor i in range(1, 6) : print(first_day_of_year(i))\n\n0\n1\n2\n3\n5\nFirst day of year 1993:\nfirst_day_of_year(1993)\n\n4\nNow we are ready to generate all the 13th days of all months of years ranging from 1993 to 2025.\nthirteenth_days = []\nfor y in range(1993, 2026) :\n    first_day = first_day_of_year(y)\n    first_thirteenth_day = (first_day + 12) % 7\n    thirteenth_days.append(days_of_the_week_that_are_thirteenth(first_thirteenth_day, is_leap(y)))\nthirteenth_days holds 33 arrays, each holding 12 values, that contains the days of the week that the 13th of the corresponding month fell on:\nprint(thirteenth_days)\nTo find out how many times ‘Friday the 13th’ was experienced since 1993, we simply have to count and add iup each occurrence of ‘4’ (Friday) in each array:\ncount = 0\nfor days in thirteenth_days :\n    for day in days :\n        if day == 4 : count += 1\n\nprint(count)\n\n55\nSo Friday the 13th was experienced 55 times in total since year 1993. Finally, we can encapsulate all of this computation in a single function:\ndef count_friday_13th_since(year) :\n    thirteenth_days = []\n    for y in range(year, 2026) :\n        first_day = first_day_of_year(y)\n        first_thirteenth_day = (first_day + 12) % 7\n        thirteenth_days.append(\n            days_of_the_week_that_are_thirteenth(first_thirteenth_day, is_leap(y)))\n    count = 0\n    for days in thirteenth_days :\n        for day in days :\n            if day == 4 : count += 1\n    return count\n\n\ncount_friday_13th_since(2000)  \n\n44",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh01/sh01.html#friday-the-13th",
    "href": "sh01/sh01.html#friday-the-13th",
    "title": "1  Sheet 1",
    "section": "",
    "text": "1st day of a non-leap year: January 1st\n255th day of a non-leap year: September 12th\n366th day of a leap year: December 31st\n60th day of a leap year: February 29th",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh01/sh01.html#stable-glasses",
    "href": "sh01/sh01.html#stable-glasses",
    "title": "1  Sheet 1",
    "section": "Stable Glasses",
    "text": "Stable Glasses\n\nLinear search: 30 tries in worst case, corresponding to the situation when the glass breaks at the highest platform. We start at the bottom platfrom and move to the next higher one if the glass doesn’t break. As soon as the glass breaks we know that the platform just below is the maximum height the glass can withstand..\nBinary search: 5 tries always. In worst case each time we try the glass breaks. Therefore, maximum amount of broken glasses is 5. This corresponds to the situation where no height is safe for the glass.\nJustification: The general strategy is the same as with binary search - we first try the middle platform, i.e. 15th platform. In case the glass doesn’t break we know that we must search only in the upper half. Otherwise, we must search only in the lower half. Since in each step we half the amount of platforms the procedure is guaranteed to terminate in approximately \\(\\log_2{30}\\) steps. How many exactly can be seen with the following sequence: 15, 8, 4, 2, 1. Explanation of this sequence is that the middle platform where we have to perform the experiment is determined by the formula: (total platforms left + 1) // 2. And the total platforms left in the next step is always the number of the middle platform from the previous step. So in total there will be 5 steps and each time a glass will break.\nIn this case we can determine the highest platform in 11 steps at worst case with the following procedure (by dividing the stand in 3 equal parts)\n\nTest first glass in the highest platform in the lower third, i.e. the 11th platform. If it breaks then we must test the other glass in the remaining 10 platforms in the lower third linearly until it breaks the first time: 10 + 1 = 11 tries at worst.\nif the first glass doesn’t break, then we try the lowest platform in the upper third, i.e. the 21st platform with this glass. If the glass breaks here, then we search the middle third, i.e. we test the platforms 12..20 with the other glass linearly, until it breaks. This totals to 1 + 1 + 9 = 11 tries in worst case.\nIf first glass doesn’t break in the 21st platform, then we continue to search the upper third platform with it, namely the platforms 22…30, linearly until the glass breaks or we reach the end. This totals to 1 + 1 + 9 = 11 tries in worst case.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh01/sh01.html#python-documentation",
    "href": "sh01/sh01.html#python-documentation",
    "title": "1  Sheet 1",
    "section": "Python Documentation",
    "text": "Python Documentation\nChapters 3, 4.1 - 4.9.2, 8.1 - 8.4, 9.3, and 10.6\n\ndef reverse(s) :\n    if len(s) == 0 : return s\n    return s[-1] + reverse(s[: len(s) - 1])\n\n\nreverse('he')\n\n'eh'\n\n\n\ndef palindrom(s) -&gt; bool :\n    return s == reverse(s)\n\n\npalindrom('ccababaccd')\n\nFalse\n\n\n\ndef fib(limit):\n    a, b = 0, 1\n    # \n    # there exist i: a == fib(i), b == fib(i + 1)\n    while (a &lt; limit) :\n        a, b = b, a + b\n    # a &gt;= limit\n    return(a)\n    \n\n\nfib(144)\n\n144\n\n\n\nd = {\"a\" : \"active\", \"b\" : \"inactive\", \"c\" : \"active\"}\n\nfor i, j in d.items() : \n    print(i, j)\n\nfor i, j in d.copy().items() :\n    if j == 'inactive' : del d[i]\n\nd2 = {}\nd2[\"igor\"] = 31\nd2[\"igor\"] += 1\nd2\n\na active\nb inactive\nc active\n\n\n{'igor': 32}\n\n\n\nlist(range(5, 10))\nlist(range(0, 10, 3))\nlist(range(-10, -100, -30))\n\na = ['mary', 'had', 'a', 'little', 'lamb']\nb = []\nfor i in range(len(a)):\n    b.append((i, a[i]))\n\nb\nd = dict(b)\nd\n\nfor i, word in enumerate(a) :\n    print(f\"{i}: {a[i]}\" + i**2*\"!\")\n\n0: mary\n1: had!\n2: a!!!!\n3: little!!!!!!!!!\n4: lamb!!!!!!!!!!!!!!!!\n\n\n\ndict(enumerate(list(range(5))))\n\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n\n\n\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0: \n            print(f\"{n} equals {x} * {n // x}\")\n            break \n    else: # loop fell through withouit finding a factor\n        print(n, 'is a prime number')\n        \n\n\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n\n\n\nfor num in range(2, 10):\n    if num % 2 == 0:\n        print(f\"Found an even number {num}\")\n        continue\n    print(f\"Found an odd number {num}\")\n\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n\n\n\ndef http_error(status):\n    match status:\n        case 400: return \"Bad Request\"\n        case 404: return \"Not found\"\n        case 418: return \"I'm a teapot\"\n        case 401 | 403 | 402: return \"Not allowed\"\n        case _: return \"Something's wrong\"\n\nfor i in [400, 404, 418, 134] : print(http_error(i))\n\nfor i in ['a', 'b']: print(i)\n\nprint(http_error(401))\n\nBad Request\nNot found\nI'm a teapot\nSomething's wrong\na\nb\nNot allowed\n\n\n\nnums = [1, 2, 3]\na, b, c = nums\nprint(a, b, c)\n\ndef add(a, b, c) :\n    return a + b + c\n\nadd(1, 2, 3)\nadd(*nums)\n\na, *b, c = [1, 2, 3, 4]\nprint(a, b, c)\na, *b, c = 1, 2, 3, 4\nprint(a, b, c)\n\n1 2 3\n1 [2, 3] 4\n1 [2, 3] 4\n\n\n\nx, y = 1, 2\nprint(x, y)\nx, y = [1, 2]\nprint(x, y)\nx, y = (1, 2)\nprint(x, y)\n\n*head, last = 1, 2, 3, 4\nprint(head, last)\n*head, last = [1, 2, 3, 4]\nprint(head, last)\nfirst, *middle, last = (1, 2, 3, 4, 5)\nprint(first, middle, last)\nx,*_, z = 1, 2, 3, 4\nprint(x, z)\na, *b, c, d = range(10)\nprint(a, b, c, d)\n\n1 2\n1 2\n1 2\n[1, 2, 3] 4\n[1, 2, 3] 4\n1 [2, 3, 4] 5\n1 4\n0 [1, 2, 3, 4, 5, 6, 7] 8 9\n\n\n** operator works with dictionaries to unpack keyword arguments\n\ndef greet(name, greeting):\n    print(f\"{greeting}, {name}!\")\n\nparams = {\"name\": \"Alice\", \"greeting\": \"Hello\"}\n\ngreet(**params)\n\nHello, Alice!\n\n\n\na, *b, c = 1,2\n# print(a, b, c)\n\ndef foo(a, *args, **kwargs):\n    print(a)\n    print(args)\n    print(kwargs)\n\nfoo(1, 2, 3, 4, x = 10, y = 20, z = 30)\n\n1\n(2, 3, 4)\n{'x': 10, 'y': 20, 'z': 30}\n\n\n\ndef bar(*args):\n    print(args)\n\n\nl = [1, 2, 3]\n\nbar(l, *l)\n\n([1, 2, 3], 1, 2, 3)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh02/sh02.html",
    "href": "sh02/sh02.html",
    "title": "2  Sheet 1",
    "section": "",
    "text": "Properties of Sorting Algorithms\nimport random\n\ndef insertion_sort(a) :\n    N = len(a)\n    count = 0\n    # i = 1\n    # sorted(a[0..i-1])\n    for i in range(1, N):\n        k = i\n        while k &gt; 0 :\n            if a[k] &lt; a[k-1]: \n                a[k], a[k-1] = a[k-1], a[k]\n                count += 1\n            else: \n                count += 1\n                break\n            k -= 1\n    return count\n\nN = 20\na = list(range(N))\n# random.shuffle(a)\nprint(f\"a: {a}\")\ncount = insertion_sort(a)\nprint(f\"a: {a}\\ncount: {count}\")\n\n\n\n\n\n\na: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\na: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\ncount: 19\nNow we write a simple script that aggregates the counts of insertion sorts in a list, and subsequently plot the list:l\nimport matplotlib.pyplot as plt\n\ninsertion_counts = []\nfor N in range(100):\n    a = list(range(N))\n    random.shuffle(a)\n    insertion_counts.append(insertion_sort(a))\n\n\nquick_counts = []\nfor N in range(100):\n    a = list(range(N))\n    # random.shuffle(a)\n    quick_counts.append(insertion_sort(a))\n\nplt.plot(insertion_counts)\nplt.plot(quick_counts)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  },
  {
    "objectID": "sh02/sh02.html#properties-of-sorting-algorithms",
    "href": "sh02/sh02.html#properties-of-sorting-algorithms",
    "title": "2  Sheet 1",
    "section": "",
    "text": ":= means ‘defined as’:\n\na &lt; b := not ( b &lt;= a)\na &gt; b := b &lt; a (utilize the definition above)\na &gt;= b := b &lt;= a\na == b := (a &lt;= b) and (b &lt;= a)\na != b := not (a == b) (again utlizing the previous definiton)\n\nThe following \\(N - 1\\) tests are sufficient:\n1) a[0] &lt;= a[1], \n2) a[1] &lt;= a[2], \n...\nN-1) a[N-2] &lt;= a[N-1]\nProof: assume the previous \\(N - 1\\) have passed. Let \\(i\\in [0..N-2]\\) and \\(j \\in [i+1..N-1]\\) be arbitrary indices.\nSince the ordering is total, transitivity holds. Specifically having a[i] &lt;= a[i + 1] and a[i + 1] &lt;= a[i + 2] we can deduce by transitivity that a[i] &lt;= a[i + 2]. Now having this result and the condition that a[i+2] &lt;= a[i+3] we can again deduce by transitivity that a[i] &lt;= a[i + 3]\nApplying such a transitivity chain \\(j - i\\) times we will obtain a[i] &lt;= a[j]. Since \\(i\\) and \\(j\\) were arbitrary, s.t. \\(i &lt; j\\), this concludes our proof.\nThe usual versions of insertion_sort() and quick_sort(), without counting are given as follows\ndef insertion_sort(a) :\n   N = len(a)\n   # i = 0\n   # sorted(a[0..i])\n   for i in range(N):\n      k = i + 1\n      while k &gt; 0 :\n         if a[k] &lt; a[k-1]: a[k], a[k-1] = a[k-1], a[k]\n         else: break\n         k -= 1\n\ndef quick_sort(a) :\n   # TODO\nWe modify them slightly to return the number of comparisons as follows:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sheet 1</span>"
    ]
  }
]